### 什么是协程？轻量级非抢占式线程，很多语言支持，比如Go、Python、Lua等。将每个协程的上下文不是保存在堆栈上，而是其他地方，当协程之间相互调用时，被调用的协程只要从堆栈以外的地方恢复上次让出前的上下文即可。### 对称协程和非对称协程1. 对称协程：协程在执行过程中可以将控制权传递给其他协程，不存在调用与被调用的关系。比如 goroutines。2. 非对称协程：协程间的地位是不对等的，存在两种转移程序控制权的操作：resume 调用协程；yield 挂起协程将程序控制权返回给该协程的调用者。跟平时写的调用一个函数很相似，有良好的调用层次关系。比如 Libco。### 协程的结构(以Libco为例)协程是轻量级的线程，那线程要考虑有哪些东西呢？1. 线程执行的程序，想想 pthread_create() 函数；	线程创建函数原型：	`int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg)`	协程创建函数原型：	`int 	co_create( stCoRoutine_t **co,const stCoRoutineAttr_t *attr,void *(*routine)(void*),void *arg );`	传入的第三个函数就是协程要执行的程序。2. 线程有自己的私有栈，同一进程的线程共享进程内存地址空间；	协程只有栈空间，没有堆空间。还要为创建的协程准备一段栈内存空间，来保存调用过程中的变量。3. 控制块，唯一标识线程，记录它占有的资源。	调用 co_create() 时，会创建一个 stCoRoutine_t 的结构指针，就是第一个参数来标识，这个结构代表了 Libco 的协程，记录协程占有的资源。    ```    struct stCoRoutine_t    {        // 协程执行的环境，创建时跟所在的线程绑定        // 同属于一个线程所有协程的执行环境，是一个全局概念        stCoRoutineEnv_t *env;        // pfn 是协程执行的函数指针，在创建协程的时候传进来的        pfn_co_routine_t pfn;        // 函数的参数        void *arg;        // 这个结构是用来保存协程执行上下文信息的，就是一些寄存器的值        coctx_t ctx;        /* 下面是协程的一些标志和状态*/        // 是否开始        char cStart;        // 是否结束        char cEnd;        // 是否是主协程        char cIsMain;        // 是否开启Hook系统调用        char cEnableSysHook;        // 是否共享栈        char cIsShareStack;        // 一个用于保存程序系统环境变量的指针        void *pvEnv;        // 协程运行时的私有栈内存，是固定的 128K 大小        //char sRunStack[ 1024 * 128 ];        stStackMem_t* stack_mem;        // 涉及到协程私有栈内存是共享栈还是独立栈        //save satck buffer while confilct on same stack_buffer;        char* stack_sp;         unsigned int save_size;        char* save_buffer;        // 用来保存协程的私有数据        stCoSpec_t aSpec[1024];    };   	```	```    struct stCoRoutineEnv_t    {        // 非对称协程下被调协程只能返回到调用协程        // 调用栈，这个就是保存调用顺序的栈        // 每当启动一个协程，就将它的stCoRoutine_t 结构指针保存在pCallStack 栈顶        // iCallStackSize 值加 1        // 当协程让出CPU时，yield ,就把它的结构指针从 pCallStack 弹出，iCallStackSize值减1        stCoRoutine_t *pCallStack[ 128 ];        int iCallStackSize;        stCoEpoll_t *pEpoll;        // 共享栈时才有用，否则就是空指针        //for copy stack log lastco and nextco        stCoRoutine_t* pending_co;        stCoRoutine_t* occupy_co;    };    ```   实际上，Libco 的第一个协程就是执行 main 函数的协程，又称为主协程，负责协调其他协程的调度执行，在CallStack 栈底，自己不会主动 yield 让出控制权。主协程是和 stCoRoutineEnv_t 一起创建的，当程序第一次调用 co_create()时，这个函数会判断当前线程的 stCoRoutineEnv_t 结构是否已分配，如果未分配则分配一个，同时分配一个 stCoRoutine_t 结构，并将 pCallStack[0] 指向主协程。  	pEpoll 的作用主要是事件管理包括网络IO和定时事件，主协程最终调用 co_eventloop()，这是个基于epoll/kqueue的事件循环，负责调度其他协程运行。下面提到。### 主要的几个方法```int 	co_create( stCoRoutine_t **co,const stCoRoutineAttr_t *attr,void *(*routine)(void*),void *arg );void    co_resume( stCoRoutine_t *co );void    co_yield( stCoRoutine_t *co );void    co_yield_ct(); //ct = current threadvoid    co_release( stCoRoutine_t *co );```不同于线程，协程创建之后不是立即执行，而需要唤醒之后才执行，所以 create 和 resume 往往同时出现，yield 则是挂起协程。可以认为libco 的协程只有两种状态，即 running 和 pending，当创建一个协程并 resume 之后这个协程便进入了 running 状态，之后此协程可能通过 yield 让出CPU，这就进入了 pending 状态，它是不断在这两个状态间往复，直到协程退出。这几个 yield 函数本质其实是一样的，不同于 co_resume 是有明确目的对象的，可以通过 resume 将CPU交给任意协程，但是 yield 不一样，只能 yield 给当前协程的调用者，就是最初 resume 当前协程的协程，保存在 stCoRoutineEnv_t 的 pCallStack 中的。同一个线程上所有协程共享同一个 环境变量，所以任意协程的 co-> env 指向的结构是相同的。看过 这两个函数的实现后发现，这两个函数的过程是相反的，它们有一个共同的核心任务就是 co_swap，切换CPU执行上下文，完成协程的切换。co_swap()  是比较核心的部分。co_release，协程执行结束，释放协程占的内存空间。### 事件驱动与协程调度非对称协程里面，没有专门的调度算法，libco 协程之间的调度是与事件驱动紧紧联系在一起的，这里的“调度算法”也可以说是基于epoll/kqueue事件驱动的调度算法，libco 中的主协程就起到这样的作用。#### 相关的结构：    ```    struct stCoEpoll_t    {    	// epfd        int iEpollFd;        // epoll_wait 第三个参数        static const int _EPOLL_SIZE = 1024 * 10;		// 时间轮定时器        struct stTimeout_t *pTimeout;        // 链表头，这个链表存放超时事件的 item        struct stTimeoutItemLink_t *pstTimeoutList;		// 存放epoll_wait得到的就绪事件和定时器超时事件        struct stTimeoutItemLink_t *pstActiveList;		// 指向 co_epoll_res 结构的指针，是对epoll_wait第二个参数的封装        // 是一次 epoll_wait 得到的结果集合        co_epoll_res *result;     };    ```#### 定时器事件驱动模型必不可少的功能，比如网络IO的超时、定时任务。定时器一般由两部分组成，一个是描述时间事件的数据结构，另一部分是定时通知机制。Nginx 选的红黑树，Libco 用的是时间轮，Redis 用的是链表来作为 timer events 的数据结构。定时通知一般用 epoll/kqueue 这样的调用来完成定时通知，这样定时事件通知与网络I/O事件通知的逻辑就能统一起来了。#### Libco 中什么时候调用 resume 和 yield？3 种调用 yield 让出CPU的场景：- 用户程序主动调用 co_yield_ct();- 程序调用了 poll() 或 co_cond_timedwait()；- 程序调用 connect()、read()、write()、recv()、send()等系统调用。相应地，重新 resume 启动一个协程也有三种情况：- 用户程序主动调 co_resume() 将协程启动起来；- poll() 的目标文件描述符事件就绪或超时，co_cond_timedwait() 等待了其他协程的 co_cond_signal() 通知信号或等待超时；- read()、write()等IO接口成功读到或写入数据或者读写超时。第一种情况，在 example_echosvr.cpp 例子中就有，用户主动 yield 和 resume 协程。第二种情况，在 example_cond.cpp 例子中的生产者消费者模型就是这种情况，第三种情况，调用 read()、write()等I/O操作而陷入"阻塞"和最后又恢复执行的过程。这里的"阻塞"是用户态实现的过程，libco 的协程是在线程上串行执行的，如果调用 read、write 导致当前线程被内核挂起而陷入真正的阻塞，那么所有的协程都不能执行了。所以为了避免陷入内核态阻塞，必须要将 sockfd 设置为 non-blocking 的。